{"meta":{"title":"凌可语-lingkeyu","subtitle":"如梦初醒 始料未及 别来无恙~","description":null,"author":"凌可语","url":"http://lingkeyu.com"},"pages":[{"title":"分类","date":"2018-08-09T16:33:27.000Z","updated":"2018-09-01T13:11:58.738Z","comments":false,"path":"categories/index.html","permalink":"http://lingkeyu.com/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-08-09T16:33:58.000Z","updated":"2018-08-16T12:35:58.000Z","comments":false,"path":"tags/index.html","permalink":"http://lingkeyu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试题-算法专题","slug":"面试题-算法专题","date":"2018-05-18T15:48:17.000Z","updated":"2018-09-02T05:20:32.396Z","comments":true,"path":"2018/05/18/面试题-算法专题/","link":"","permalink":"http://lingkeyu.com/2018/05/18/面试题-算法专题/","excerpt":"阐述下 JavaScript 中的变量提升所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。","text":"阐述下 JavaScript 中的变量提升所谓提升，顾名思义即是 JavaScript 会将所有的声明提升到当前作用域的顶部。这也就意味着我们可以在某个变量声明前就使用该变量，不过虽然 JavaScript 会将声明提升到顶部，但是并不会执行真的初始化过程。 阐述下 use strict; 的作用use strict; 顾名思义也就是 JavaScript 会在所谓严格模式下执行，其一个主要的优势在于能够强制开发者避免使用未声明的变量。对于老版本的浏览器或者执行引擎则会自动忽略该指令。 1234567// Example of strict mode\"use strict\";catchThemAll();function catchThemAll() &#123; x = 3.14; // Error will be thrown return x * x;&#125; 解释下什么是 Event Bubbling 以及如何避免Event Bubbling 即指某个事件不仅会触发当前元素，还会以嵌套顺序传递到父元素中。直观而言就是对于某个子元素的点击事件同样会被父元素的点击事件处理器捕获。避免 Event Bubbling 的方式可以使用event.stopPropagation() 或者 IE 9 以下使用event.cancelBubble。 == 与 === 的区别是什么=== 也就是所谓的严格比较，关键的区别在于=== 会同时比较类型与值，而不是仅比较值。 12345// Example of comparators0 == false; // true0 === false; // false2 == '2'; // true2 === '2'; // false 解释下 null 与 undefined 的区别JavaScript 中，null 是一个可以被分配的值，设置为 null 的变量意味着其无值。而 undefined 则代表着某个变量虽然声明了但是尚未进行过任何赋值。 解释下 原型继承 与 类继承 的区别在类继承中，类是不可变的，不同的语言中对于多继承的支持也不一样，有些语言中还支持接口、final、abstract 的概念。而原型继承则更为灵活，原型本身是可以可变的，并且对象可能继承自多个原型。 数组找出整型数组中乘积最大的三个数给定一个包含整数的无序数组，要求找出乘积最大的三个数。 12345678910111213141516171819var unsorted_array = [-10, 7, 29, 30, 5, -10, -70];computeProduct(unsorted_array); // 21000function sortIntegers(a, b) &#123; return a - b;&#125;// greatest product is either (min1 * min2 * max1 || max1 * max2 * max3)function computeProduct(unsorted) &#123; var sorted_array = unsorted.sort(sortIntegers), product1 = 1, product2 = 1, array_n_element = sorted_array.length - 1; // Get the product of three largest integers in sorted array for (var x = array_n_element; x &gt; array_n_element - 3; x--) &#123; product1 = product1 * sorted_array[x]; &#125; product2 = sorted_array[0] * sorted_array[1] * sorted_array[array_n_element]; if (product1 &gt; product2) return product1; return product2&#125;; 寻找连续数组中的缺失数给定某无序数组，其包含了 n 个连续数字中的 n – 1 个，已知上下边界，要求以O(n)的复杂度找出缺失的数字。 1234567891011121314151617181920// The output of the function should be 8var array_of_integers = [2, 5, 1, 4, 9, 6, 3, 7];var upper_bound = 9;var lower_bound = 1;findMissingNumber(array_of_integers, upper_bound, lower_bound); //8function findMissingNumber(array_of_integers, upper_bound, lower_bound) &#123; // Iterate through array to find the sum of the numbers var sum_of_integers = 0; for (var i = 0; i &lt; array_of_integers.length; i++) &#123; sum_of_integers += array_of_integers[i]; &#125; // 以高斯求和公式计算理论上的数组和 // Formula: [(N * (N + 1)) / 2] - [(M * (M - 1)) / 2]; // N is the upper bound and M is the lower bound upper_limit_sum = (upper_bound * (upper_bound + 1)) / 2; lower_limit_sum = (lower_bound * (lower_bound - 1)) / 2; theoretical_sum = upper_limit_sum - lower_limit_sum; // return (theoretical_sum - sum_of_integers)&#125; 数组去重给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。 123456789101112131415161718// ES6 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]// ES5 Implementationvar array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];uniqueArray(array); // [1, 2, 3, 5, 9, 8]function uniqueArray(array) &#123; var hashmap = &#123;&#125;; var unique = []; for(var i = 0; i &lt; array.length; i++) &#123; // If key returns null (unique), it is evaluated as false. if(!hashmap.hasOwnProperty([array[i]])) &#123; hashmap[array[i]] = 1; unique.push(array[i]); &#125; &#125; return unique;&#125; 数组中元素最大差值计算给定某无序数组，求取任意两个元素之间的最大差值，注意，这里要求差值计算中较小的元素下标必须小于较大元素的下标。譬如[7, 8, 4, 9, 9, 15, 3, 1, 10]这个数组的计算值是 11( 15 – 4 ) 而不是 14(15 – 1)，因为 15 的下标小于 1。 1234567891011121314151617181920212223var array = [7, 8, 4, 9, 9, 15, 3, 1, 10];// [7, 8, 4, 9, 9, 15, 3, 1, 10] would return `11` based on the difference between `4` and `15`// Notice: It is not `14` from the difference between `15` and `1` because 15 comes before 1.findLargestDifference(array);function findLargestDifference(array) &#123; // 如果数组仅有一个元素，则直接返回 -1 if (array.length &lt;= 1) return -1; // current_min 指向当前的最小值 var current_min = array[0]; var current_max_difference = 0; // 遍历整个数组以求取当前最大差值，如果发现某个最大差值，则将新的值覆盖 current_max_difference // 同时也会追踪当前数组中的最小值，从而保证 `largest value in future` - `smallest value before it` for (var i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; current_min &amp;&amp; (array[i] - current_min &gt; current_max_difference)) &#123; current_max_difference = array[i] - current_min; &#125; else if (array[i] &lt;= current_min) &#123; current_min = array[i]; &#125; &#125; // If negative or 0, there is no largest difference if (current_max_difference &lt;= 0) return -1; return current_max_difference;&#125; 数组中元素乘积给定某无序数组，要求返回新数组 output ，其中 output[i] 为原数组中除了下标为 i 的元素之外的元素乘积，要求以 O(n) 复杂度实现： 123456789101112131415161718192021222324252627var firstArray = [2, 2, 4, 1];var secondArray = [0, 0, 0, 2];var thirdArray = [-2, -2, -3, 2];productExceptSelf(firstArray); // [8, 8, 4, 16]productExceptSelf(secondArray); // [0, 0, 0, 0]productExceptSelf(thirdArray); // [12, 12, 8, -12]function productExceptSelf(numArray) &#123; var product = 1; var size = numArray.length; var output = []; // From first array: [1, 2, 4, 16] // The last number in this case is already in the right spot (allows for us) // to just multiply by 1 in the next step. // This step essentially gets the product to the left of the index at index + 1 for (var x = 0; x &lt; size; x++) &#123; output.push(product); product = product * numArray[x]; &#125; // From the back, we multiply the current output element (which represents the product // on the left of the index, and multiplies it by the product on the right of the element) var product = 1; for (var i = size - 1; i &gt; -1; i--) &#123; output[i] = output[i] * product; product = product * numArray[i]; &#125; return output;&#125; 数组交集给定两个数组，要求求出两个数组的交集，注意，交集中的元素应该是唯一的。 12345678910111213141516171819202122var firstArray = [2, 2, 4, 1];var secondArray = [1, 2, 0, 2];intersection(firstArray, secondArray); // [2, 1]function intersection(firstArray, secondArray) &#123; // The logic here is to create a hashmap with the elements of the firstArray as the keys. // After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash // If it does exist, add that element to the new array. var hashmap = &#123;&#125;; var intersectionArray = []; firstArray.forEach(function(element) &#123; hashmap[element] = 1; &#125;); // Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added secondArray.forEach(function(element) &#123; if (hashmap[element] === 1) &#123; intersectionArray.push(element); hashmap[element]++; &#125; &#125;); return intersectionArray; // Time complexity O(n), Space complexity O(n)&#125; 字符串颠倒字符串给定某个字符串，要求将其中单词倒转之后然后输出，譬如”Welcome to this Javascript Guide!” 应该输出为 “emocleW ot siht tpircsavaJ !ediuG”。 12345678var string = \"Welcome to this Javascript Guide!\";// Output becomes !ediuG tpircsavaJ siht ot emocleWvar reverseEntireSentence = reverseBySeparator(string, \"\");// Output becomes emocleW ot siht tpircsavaJ !ediuGvar reverseEachWord = reverseBySeparator(reverseEntireSentence, \" \");function reverseBySeparator(string, separator) &#123; return string.split(separator).reverse().join(separator);&#125; 乱序同字母字符串给定两个字符串，判断是否颠倒字母而成的字符串，譬如Mary与Army就是同字母而顺序颠倒： 123456789101112var firstWord = \"Mary\";var secondWord = \"Army\";isAnagram(firstWord, secondWord); // truefunction isAnagram(first, second) &#123; // For case insensitivity, change both words to lowercase. var a = first.toLowerCase(); var b = second.toLowerCase(); // Sort the strings, and join the resulting array to a string. Compare the results a = a.split(\"\").sort().join(\"\"); b = b.split(\"\").sort().join(\"\"); return a === b;&#125; 会问字符串判断某个字符串是否为回文字符串，譬如racecar与race car都是回文字符串： 12345678isPalindrome(\"racecar\"); // trueisPalindrome(\"race Car\"); // truefunction isPalindrome(word) &#123; // Replace all non-letter chars with \"\" and change to lowercase var lettersOnly = word.toLowerCase().replace(/\\s/g, \"\"); // Compare the string with the reversed version of the string return lettersOnly === lettersOnly.split(\"\").reverse().join(\"\");&#125; 栈与队列使用两个栈实现入队与出队123456789101112131415161718var inputStack = []; // First stackvar outputStack = []; // Second stack// For enqueue, just push the item into the first stackfunction enqueue(stackInput, item) &#123; return stackInput.push(item);&#125;function dequeue(stackInput, stackOutput) &#123; // Reverse the stack such that the first element of the output stack is the // last element of the input stack. After that, pop the top of the output to // get the first element that was ever pushed into the input stack if (stackOutput.length &lt;= 0) &#123; while(stackInput.length &gt; 0) &#123; var elementToOutput = stackInput.pop(); stackOutput.push(elementToOutput); &#125; &#125; return stackOutput.pop();&#125; 判断大括号是否闭合创建一个函数来判断给定的表达式中的大括号是否闭合： 1234567891011121314151617181920212223242526var expression = \"&#123;&#123;&#125;&#125;&#123;&#125;&#123;&#125;\"var expressionFalse = \"&#123;&#125;&#123;&#123;&#125;\";isBalanced(expression); // trueisBalanced(expressionFalse); // falseisBalanced(\"\"); // truefunction isBalanced(expression) &#123; var checkString = expression; var stack = []; // If empty, parentheses are technically balanced if (checkString.length &lt;= 0) return true; for (var i = 0; i &lt; checkString.length; i++) &#123; if(checkString[i] === '&#123;') &#123; stack.push(checkString[i]); &#125; else if (checkString[i] === '&#125;') &#123; // Pop on an empty array is undefined if (stack.length &gt; 0) &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; &#125; // If the array is not empty, it is not balanced if (stack.pop()) return false; return true;&#125; 递归二进制转换通过某个递归函数将输入的数字转化为二进制字符串： 123456789101112131415161718decimalToBinary(3); // 11decimalToBinary(8); // 1000decimalToBinary(1000); // 1111101000function decimalToBinary(digit) &#123; if(digit &gt;= 1) &#123; // If digit is not divisible by 2 then recursively return proceeding // binary of the digit minus 1, 1 is added for the leftover 1 digit if (digit % 2) &#123; return decimalToBinary((digit - 1) / 2) + 1; &#125; else &#123; // Recursively return proceeding binary digits return decimalToBinary(digit / 2) + 0; &#125; &#125; else &#123; // Exit condition return ''; &#125;&#125; 二分搜索123456789101112function recursiveBinarySearch(array, value, leftPosition, rightPosition) &#123; // Value DNE if (leftPosition &gt; rightPosition) return -1; var middlePivot = Math.floor((leftPosition + rightPosition) / 2); if (array[middlePivot] === value) &#123; return middlePivot; &#125; else if (array[middlePivot] &gt; value) &#123; return recursiveBinarySearch(array, value, leftPosition, middlePivot - 1); &#125; else &#123; return recursiveBinarySearch(array, value, middlePivot + 1, rightPosition); &#125;&#125; 数字判断是否为 2 的指数值123456789101112131415161718192021isPowerOfTwo(4); // trueisPowerOfTwo(64); // trueisPowerOfTwo(1); // trueisPowerOfTwo(0); // falseisPowerOfTwo(-1); // false// For the non-zero case:function isPowerOfTwo(number) &#123; // `&amp;` uses the bitwise n. // In the case of number = 4; the expression would be identical to: // `return (4 &amp; 3 === 0)` // In bitwise, 4 is 100, and 3 is 011. Using &amp;, if two values at the same // spot is 1, then result is 1, else 0. In this case, it would return 000, // and thus, 4 satisfies are expression. // In turn, if the expression is `return (5 &amp; 4 === 0)`, it would be false // since it returns 101 &amp; 100 = 100 (NOT === 0) return number &amp; (number - 1) === 0;&#125;// For zero-case:function isPowerOfTwoZeroCase(number) &#123; return (number !== 0) &amp;&amp; ((number &amp; (number - 1)) === 0);&#125;","categories":[{"name":"面试题","slug":"面试题","permalink":"http://lingkeyu.com/categories/面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://lingkeyu.com/tags/面试题/"},{"name":"算法","slug":"算法","permalink":"http://lingkeyu.com/tags/算法/"}]},{"title":"Vue学习笔记(三)-vue实例的生命周期","slug":"Vue学习笔记(三)-生命周期","date":"2018-04-02T15:02:01.000Z","updated":"2018-09-01T13:04:13.918Z","comments":true,"path":"2018/04/02/Vue学习笔记(三)-生命周期/","link":"","permalink":"http://lingkeyu.com/2018/04/02/Vue学习笔记(三)-生命周期/","excerpt":"Vue学习笔记(三)vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件","text":"Vue学习笔记(三)vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； 12345678910111213141516171819202122232425262728293031323334const http = require('http'); // 导入解析 URL 地址的核心模块 const urlModule = require('url'); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125; &#125;); server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000'); &#125;); 123456789105. vue-resource 的配置步骤： + 直接在页面中，通过`script`标签，引入 `vue-resource` 的脚本文件； + 注意：引用的先后顺序是：先引用 `Vue` 的脚本文件，再引用 `vue-resource` 的脚本文件；6. 发送get请求：```javascriptgetInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type=\"text\" v-model=\"searchName\"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for=\"item in search(searchName)\"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = \"\") &#123; // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；","categories":[{"name":"vue","slug":"vue","permalink":"http://lingkeyu.com/categories/vue/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"},{"name":"基础知识","slug":"基础知识","permalink":"http://lingkeyu.com/tags/基础知识/"},{"name":"vue 知识","slug":"vue-知识","permalink":"http://lingkeyu.com/tags/vue-知识/"}]},{"title":"Vue学习笔记(二)","slug":"vue学习笔记(二)","date":"2018-03-26T13:22:41.000Z","updated":"2018-09-01T13:05:18.975Z","comments":true,"path":"2018/03/26/vue学习笔记(二)/","link":"","permalink":"http://lingkeyu.com/2018/03/26/vue学习笔记(二)/","excerpt":"Vue学习笔记(二)Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐","text":"Vue学习笔记(二)Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = \"\") &#123; // 在参数列表中 通过 pattern=\"\" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type=\"text\" v-model=\"name\" @keyup.f2=\"add\"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type=\"text\" v-model=\"searchName\" v-focus v-color=\"'red'\" v-font-weight=\"900\"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式：1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理","categories":[{"name":"vue","slug":"vue","permalink":"http://lingkeyu.com/categories/vue/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"},{"name":"基础知识","slug":"基础知识","permalink":"http://lingkeyu.com/tags/基础知识/"},{"name":"vue 知识","slug":"vue-知识","permalink":"http://lingkeyu.com/tags/vue-知识/"}]},{"title":"Vue学习笔记(一)","slug":"vue学习笔记(一)","date":"2018-03-17T03:02:31.000Z","updated":"2018-09-01T13:04:20.906Z","comments":true,"path":"2018/03/17/vue学习笔记(一)/","link":"","permalink":"http://lingkeyu.com/2018/03/17/vue学习笔记(一)/","excerpt":"Vue学习笔记(一)什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！","text":"Vue学习笔记(一)什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 基本代码 和 MVVM 之间的对应关系Vue之 - 基本的代码结构和插值表达式、v-cloakVue指令之v-text和v-htmlVue指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; Vue指令之v-on和跑马灯效果跑马灯效果 HTML结构： 12345678910&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"开启\" v-on:click=\"go\"&gt; &lt;input type=\"button\" value=\"停止\" v-on:click=\"stop\"&gt; &lt;/div&gt; Vue实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; info: 'vue轻便 易上手~！', intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"n1\"&gt; &lt;select v-model=\"opt\"&gt; &lt;option value=\"0\"&gt;+&lt;/option&gt; &lt;option value=\"1\"&gt;-&lt;/option&gt; &lt;option value=\"2\"&gt;*&lt;/option&gt; &lt;option value=\"3\"&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" v-model=\"n2\"&gt; &lt;input type=\"button\" value=\"=\" v-on:click=\"getResult\"&gt; &lt;input type=\"text\" v-model=\"result\"&gt;&lt;/div&gt; Vue实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '0' &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case '0': this.result = parseInt(this.n1) + parseInt(this.n2); break; case '1': this.result = parseInt(this.n1) - parseInt(this.n2); break; case '2': this.result = parseInt(this.n1) * parseInt(this.n2); break; case '3': this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在Vue中使用样式使用class样式 数组 1&lt;h1 :class=\"['red', 'thin']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=\"['red', 'thin', isactive?'active':'']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=\"['red', 'thin', &#123;'active': isactive&#125;]\"&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=\"&#123;red:true, italic:true, active:true, thin:true&#125;\"&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=\"&#123;color: 'red', 'font-size': '40px'&#125;\"&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=\"h1StyleObj\"&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: 'red', 'font-size': '40px', 'font-weight': '200' &#125;, h1StyleObj2: &#123; fontStyle: 'italic' &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=\"[h1StyleObj, h1StyleObj2]\"&gt;这是一个善良的H1&lt;/h1&gt; Vue指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for=\"(item, i) in list\"&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 1234&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for=\"(val, key, i) in userInfo\"&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 12&lt;p v-for=\"i in 10\"&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for=\"item in list | filterBy searchName in 'name'\"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type=\"text\" v-model=\"searchName\"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for=\"item in search(searchName)\"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://lingkeyu.com/categories/vue/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"},{"name":"基础知识","slug":"基础知识","permalink":"http://lingkeyu.com/tags/基础知识/"},{"name":"vue 知识","slug":"vue-知识","permalink":"http://lingkeyu.com/tags/vue-知识/"}]},{"title":"工作中需要掌握的Git命令","slug":"工作中需要掌握的Git命令","date":"2018-01-23T15:22:11.000Z","updated":"2018-09-01T13:04:47.816Z","comments":true,"path":"2018/01/23/工作中需要掌握的Git命令/","link":"","permalink":"http://lingkeyu.com/2018/01/23/工作中需要掌握的Git命令/","excerpt":"工作中需要掌握的Git命令","text":"工作中需要掌握的Git命令 初始化配置 #配置使用git仓库的人员姓名 git config –global user.name “Your Name Comes Here” #配置使用git仓库的人员email git config –global user.email you@yourdomain.example.com #配置到缓存 默认15分钟 git config –global credential.helper cache #修改缓存时间 git config –global credential.helper ‘cache –timeout=3600’ git config –global color.ui true git config –global alias.co checkout git config –global alias.ci commit git config –global alias.st status git config –global alias.br branch git config –global core.editor “mate -w” # #### 设置Editor使用textmate git config -1 #列举所有配置 #用户的git配置文件~/.gitconfig 查看、添加、提交、删除、找回，重置修改文件 git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diff git diff # 比较当前文件和暂存区文件差异 git diff git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息查看提交记录 git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息tigMac上可以使用tig代替diff和log，brew install tig 取得Git仓库 #初始化一个版本仓库 git init #Clone远程版本库 git clone git@xbc.me:wordpress.git #添加远程版本库origin，语法为 git remote add [shortname] [url] git remote add origin git@xbc.me:wordpress.git #查看远程仓库 git remote -v提交你的修改 #添加当前修改的文件到暂存区 git add . #如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件 git add -u #提交你的修改 git commit –m “你的注释” #推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支] git push origin master #查看文件状态 git status #跟踪新文件 git add readme.txt #从当前跟踪列表移除文件，并完全删除 git rm readme.txt #仅在暂存区删除，保留文件在当前目录，不再跟踪 git rm –cached readme.txt #重命名文件 git mv reademe.txt readme #查看提交的历史记录 git log #修改最后一次提交注释的，利用–amend参数 git commit –amend #忘记提交某些修改，下面的三条命令只会得到一个提交。 git commit –m &quot;add readme.txt&quot; git add readme_forgotten git commit –amend #假设你已经使用git add .，将修改过的文件a、b加到暂存区 #现在你只想提交a文件，不想提交b文件，应该这样 git reset HEAD b #取消对文件的修改 git checkout –- readme.txt查看、切换、创建和删除分支 git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase git merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用) git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功Git暂存管理 git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理 git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push删除远程分支基本的分支管理 #创建一个分支 git branch dev #切换工作目录到dev git chekcout dev #将上面的命令合在一起，创建dev分支并切换到dev git chekcout –b dev #合并dev分支，当前工作目录为master git merge dev #合并完成后，没有出现冲突，删除dev分支 git branch –d dev #拉去远程仓库的数据，语法为 git fetch [remote-name] git fetch #fetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并 git pull #查看远程仓库的信息 git remote show origin #建立本地的dev分支追踪远程仓库的develop分支 git checkout –b dev origin/developGit远程仓库管理 git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库创建远程仓库 git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库 git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[{"name":"Git","slug":"Git","permalink":"http://lingkeyu.com/categories/Git/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"Git","slug":"Git","permalink":"http://lingkeyu.com/tags/Git/"},{"name":"工作","slug":"工作","permalink":"http://lingkeyu.com/tags/工作/"}]},{"title":"个人知识总结(三)","slug":"个人知识总结(三)","date":"2017-08-20T12:12:41.000Z","updated":"2018-09-01T13:04:33.967Z","comments":true,"path":"2017/08/20/个人知识总结(三)/","link":"","permalink":"http://lingkeyu.com/2017/08/20/个人知识总结(三)/","excerpt":"个人知识总结(三)设计模式 - 单例模式模块化开发 把一个项目按照页面或者功能分割成不同的任务,交给项目中不同的成员开发.开发结束之后将代码合并到一起. 多人协作开发的问题: 变量名 函数名 冲突 为了防止全局变量污染: 闭包但是闭包并不完美,所以选择搭配设计模式来进一步进行项目开发","text":"个人知识总结(三)设计模式 - 单例模式模块化开发 把一个项目按照页面或者功能分割成不同的任务,交给项目中不同的成员开发.开发结束之后将代码合并到一起. 多人协作开发的问题: 变量名 函数名 冲突 为了防止全局变量污染: 闭包但是闭包并不完美,所以选择搭配设计模式来进一步进行项目开发 单例模式 表现形式 : 就是一个对象 : { name : xxx , age : function(){} }; 定义 : 把描述同一功能的属性和方法放到一个对象[命名空间] 在设计模式当中,这个person不仅仅是一个对象名,还是一个命名空间,多个命名空间是相互独立的,互不干扰 好处 : 不受全局变量的污染和干扰.并且可以相互调用方法 由来 : 单例模式的本质就是一个对象 , 它object类上的一个实例,实例与实例之间互不干扰,叫做单独的实例,简称 “单例” 高级单例模式 定义 : 在高级单例模式当中,我们不只会把一个对象赋值给一个命名空间,我们会让它先执行一个自执行函数, [就形成了一个闭包,一个不销毁的作用域] 在自执行函数中,返回一个对象给这个命名空间 好处 : 可以在私有的作用于当中,创建很多属性和方法,仅需要把我们使用的属性和方法暴露在这个对象当中即可 工厂模式 把实现同一功能的代码放进一个函数,当实现类似功能时,只需要执行这个函数即可,传参数不同即可,减少代码的冗余,&quot;高内聚 , 低耦合&quot; –&gt; 函数的封装 面向对象 oop / op : 面向对象缩写 , 面向对象思想 定义 : 面向类的封装继承和多态 , 通过简单的实例化,调用其它方法和属性 JS 就是通过面向对象的思想设计开发出来的 需要了解 对象 类 实例 对象 : 万物皆对象,多为一种泛指,可以是任何物体 类 : 对象中具有同一属性和特征的集合, 类又分为大类和小类 实例 : 就是类中的一个具体的细分我们研究当前实例具有哪些属性和方法,那么证明当前类中的其他实例也同样具有 JS中的内置类 JS中的任何数据类型都是它所属的类,除了null 和 undefined Number , String , Boolean , Object , Array , RegExp , Function , Date … div -&gt; HTMLDIVElement-&gt;HTML document –&gt; HTMLDocument -&gt; Document(getElementById) getElementById只在document的原型上,普通元素对象上不存在这个属性 类的首字母都是大写 类的执行通过new来执行 Object 对象类 , 被称为 基类, 在任何数据类型都可以通过__proto__[原型链] 找到基类 Object 内置类的原型只能新增, 不能用新的地址覆盖 创建类 字面量方式 实例化方式 引用数据类型方式创建 var ary = new Arry (“1”) 构造函数 定义 : 当一个函数通过new关键字来执行的时候,这个函数就不是普通函数了,它是一个构造函数,也是一个自定义类,当前的函数名就是类名,这个函数的返回值就是类的实例 为了让构造函数和普通函数有一个区别,我们建议写构造函数的时候首字母大写[类名] 注意 : 一般情况下 ,我们写业务逻辑的时候不会用到构造函数.但是在封装库,框架,插件以及组件的时候会用到构造函数模式 构造函数执行的时候,如果没有参数的时候,小括号可以不用写 let person = new Person 普通函数 和 构造函数的区别 不同点 : 构造函数运行时，形成作用域之后，在代码运行之前，首先会给当前作用域初始化一个对象；并且让当前作用域下的this指向当前这个空对象；当代码运行结束，构造函数把函数体中this返回； 构造函数如果不需要实参 , 可以省略执行的小括号; 构造函数中的this 指向当前的实例 在构造函数中.return一个基本类型值,对实例没有任何影响如果return出一个引用数据类型值,那么会把默认return的this给替换掉 instanceof检测当前实例是否属于某个类,如果属于返回true 不属于返回false in : 检测某个属性是否属于对象 ,如果属于返回true 不属于返回false 构造函数的执行过程 形成一个私有的作用域 形参赋值 变量提升 浏览器会创建一个对象 , [开辟一个新的堆内存] , 将这个对象指向了this [堆内存指针指向了this实例] 代码从上到下执行 判断当前构造函数是否有return ,如果没有return默认将实例返回,如果有return , [如果return的是基本数据类型,对实例没有影响; 如果是引用数据类型,那么实例就是该引用数据类型 构造函数中 : 建议不要轻易return引用数据类型私有属性 在构造函数中,给this添加属性值和方法,都属于当前实例的私有属性公有属性 当前实例通过__proto__找到所有的属性和方法都是属于当前实例的公有属性 实例想要调取公有属性,直接可以调取,底层就是通过__proto__去找这个属性 用 in 这种方式来判断, 当前属性名[公有属性 + 私有属性] 是否属于这个对象 console.log(&quot;hasOwnProperty&quot; in person1); Object 类提供一个hasOwnProperty,这个方法判断当前属性是否是该实例的私有属性: 返回值是布尔值 console.log(person1.hasOwnProperty(&quot;age&quot;)) //trueconsole.log(person1.hasOwnProperty(&quot;valueof&quot;)) //false 自己封装一个方法,判断当前属性是否是当前实例的一个公有属性hasPubProperty 1234567891011121314151617181920person1.__proto__.hasPubProperty = function()&#123; //console.log(1); //判断参数值是否是当前实例的一个属性 //判断是否是当前实例的一个私有属性,且取反 return str in this &amp;&amp; this.hasOwnProperty(str) 或者 /* if (str in this)&#123; if(!this.hasOwnProperty(str))&#123; return true &#125;else&#123; return false &#125;else&#123; return false &#125; &#125;*/ &#125;person1.hasPubProperty(\"a\") 如果是公有属性返回true；如果不是返回false； 原型检测属性封装function hasPublicProperty(obj,attr) { // attr 是obj的一个属性并且不是私有的； /*if(attr in obj){ if(!obj.hasOwnProperty(attr)){ return true; } }else{ return false; } return false;*/ 或者 return attr in obj &amp;&amp; !obj.hasOwnProperty(attr); } console.log(hasPublicProperty(obj, &quot;toString&quot;)); JS中的函数 普通函数 , 类(自定义类和内置类) , 函数类的实例 对象 普通对象(对象数据类型) 构造函数new出来的一个实例 也是一个对象 类上面的原型也是一个对象 函数也是一个对象 学习原型模式需要记住三句话 所有的函数数据类型( 函数 , 类 )都天生自带一个属性,叫做prototype(原型) , 它是一个对象 ,既然是对象 , 那就是一个堆内存 所有函数的原型上面(都是开辟的这个堆内存), 都天生自带一个属性,叫做constructor(构造函数) , 它指向当前类本身 所有的对象都天生自带一个属性__proto__, 它指向当前所属类的原型 函数有prototype(原型) __proto__; 12345678910111213function People(name)&#123; let age = 9; this.name = name; this.age = age; &#125; People.prototype.say = function () &#123; console.log(this); &#125;; let person1 = new People('xiaihua'); let person2 = new People('xiaoming'); //person1属于People类 //__proto__指向类People的原型prototype console.log(person1.__proto__ == People.prototype);//true 原型链 定义 : 一个实例要找属性 , 优先会去找自己的私有属性 , 如有自己的私有属性没有 , 那就通过__ proto__找到自己所属类的原型上的公有属性,如果公有属性还没有,继续通过__proto__找到自己的所属类的原型知道Object[基类]的原型上,一直找到基类还没有的话,直接返回undefined Object类和Function类 Function类: 所有的类都是通过函数的方式来创建 , 由此可以得知, 所有的类(包括基类Object)都是函数类的一个实例 判断一个实例是否属于一个类: instanceofconsole.log(Number instanceof Function); //trueconsole.log(String instanceof Function); //trueconsole.log(Object instanceof Function); //true constructor : 通过实例来调用这个方法,指向当前类本身 万物皆对象, js 中的任何数据类型都可以通过proto","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lingkeyu.com/categories/javascript/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"},{"name":"基础知识","slug":"基础知识","permalink":"http://lingkeyu.com/tags/基础知识/"}]},{"title":"个人知识总结(二)","slug":"个人知识总结(二)","date":"2017-08-17T06:52:41.000Z","updated":"2018-09-01T13:04:27.398Z","comments":true,"path":"2017/08/17/个人知识总结(二)/","link":"","permalink":"http://lingkeyu.com/2017/08/17/个人知识总结(二)/","excerpt":"个人知识总结(二)变量提升https://blog.csdn.net/zjy_android_blog/article/details/80863425https://blog.csdn.net/longwenjunjie/article/details/48163293 变量提升：在作用域形成之后代码执行之前，将所有的带var和function关键字的变量提前声明或定义 js可以在浏览器中运行 是因为浏览器给js 提供了赖以生存的环境,这个环境就是作用域 var：只是提前声明 ; 默认值为undefined function：既声明又定义 debugger : 断点","text":"个人知识总结(二)变量提升https://blog.csdn.net/zjy_android_blog/article/details/80863425https://blog.csdn.net/longwenjunjie/article/details/48163293 变量提升：在作用域形成之后代码执行之前，将所有的带var和function关键字的变量提前声明或定义 js可以在浏览器中运行 是因为浏览器给js 提供了赖以生存的环境,这个环境就是作用域 var：只是提前声明 ; 默认值为undefined function：既声明又定义 debugger : 断点 形成作用域 – 变量提升 — 代码从上到下运行 变量提升特殊情况 不管条件是否成立,都要进行变量提升 条件判断中的函数,在条件判断之前,带var 和 带function 都只声明不定义, 当条件成立之后,第一件事,就是给函数赋值,条件不成立,判断体就不执行,结合了es6 块级作用域 如果不带var 直接赋值就相当于给window直接添加了一个属性且给它赋值 带var 就相当于在全局作用域下增加了一个属性,还给全局对象window增加了一个属性 注意 : 带var的可以不赋值,但是也相当于给全局对象window增加了一个属性, 不带var的必须要赋值,否则会去全局对象window下找这个值 如果没有就报错 用逗号分隔的表示连var ; var a = 1, b = 2, c = 3; 用分号来分隔,前面带var的属于变量 ,不带var的相当于给全局对象window增加了一个属性var a = 1; b =2 ; c = 3; var a = b = c = 1; 连等 带var的是一个变量 ,其他的不带var 就相当于给全局window 增加了属性 变量提升只发生在=左边 return 后面的的内容不进行变量提升但是下面的代码要进行变量提升 12345678910 function f3()&#123; console.log(f4()); console.log(f2); return function f2()&#123; //return 后面的的内容不进行变量 提升但是下面的代码要进行变量提升 &#125;function f4()&#123; console.log(f3); &#125;&#125;f3() 1234var a = [1];b = a;b[1] = \"a\"; // b = [1,\"a\"]console.log(a); //[1,\"a\"] 变量名重复: 不再进行声明,但要重新定义 匿名函数不进行变量提升 函数当作参数的时候,不进行变量提升 自执行函数不会进行变量提升 Let const 不进行变量提升 函数的定义与执行 定义三步 : 开辟新的堆内存 存储字符串 返回内存空间地址 函数执行: 首先形成一个私有作用域,, 开辟一个栈内存 形参赋值 变量提升 代码从上到下执行 作用域是否销毁 对象的定义 开辟一个空间地址 , 堆内存 把键值对存储到堆内存下 把空间地址赋值给对象名 1234console.log (fn); // f()console.log(f); //undefinedfunction fn()&#123;&#125; //函数声明式var f = function()&#123;&#125; //函数表达式---&gt; 箭头函数 1234567 console.log (fn); // f() console.log(f); //undefined console.log(fn()) //undefined 没有return 执行了两次函数 function fn()&#123; console.log(f);&#125; //函数声明式 var f = function()&#123;&#125; 12console.log (f2) //f2 未定义 报错var f = function f2 ()&#123;&#125; 12console.log (f2) //f2 未定义 报错setTimeout (function f2 ()&#123;&#125;,2000) //函数当作参数的时候,不进行变量提升 - 123456789101112131415161718console.log(f); //函数体 function f() &#123; console.log(1); &#125; f() //88 function f() &#123; console.log(2); &#125; function f() &#123; console.log(3); &#125; f() // 88 f= 99; function f() &#123; console.log(88); &#125; f()// f is not a function; console.log(f); ES6的let和constvar与ES6中const、let声明的变量的区别https://blog.csdn.net/qq_22855325/article/details/72843456 Let 不能和函数重名 const 声明的变量,如果值是基本数据类型,那么不可以进行数据修改,如果是引用数据类型值,就可以操作引用地址,不可以替换引用地址 Let虽然不会进行变量提升,但是会先检查当前作用域下是否有重复命名 12345var a = 2; if (\" a \" in window)&#123; console,log(a); //暂时性死区,即在块级作用域下,不能提前拿到let声明的变量, let a = 1;&#125; 123for ( let i= 0 ;i &lt;10; i++)&#123; //for 循环形成的保护机制&#125;console.log(i); // let 报错 块级作用域 外界无法访问 查找上一级的作用域1. 在当前作用域下输出变量值时,首先观察是否是私有变量 如何判断一个变量是私有的 当前变量有没有被Var 过和 function 过 形参也是私有变量 2. 如果变量不是私有的,就向上一级作用域查找 上一级作用域判断函数在哪定义的,函数上一级的作用域就是谁,跟函数执行没有任何关系 但获取变量值时.首先看是否是私有变量,如过不是就向上一级作用域查找,一级一级向上,直到window为止,如果window也没有,那么就会报错,这样一级一级向上查找作用域就是作用域链. 堆内存的销毁形成两个虚拟内存 : 栈 堆 栈内存 : 作用域;引用数据类型在JS 中的{ } [ ] 都是开辟一个新的空间地址谷歌浏览器 : 每隔一段时间,自动检查占用并是否销毁火狐和IE :采用的计数的规则 , 当堆内存地址被占用一次时,计数+1 ,否则 -1 ,如果是被占用0次 ,就回收 私有作用域的销毁 函数的执行 : 形成一个私有的作用域,提供代码运行环境,存储基本数据类型 闭包 : 保护里面的私有变量不受外界干扰 存储值 保存机制 : 当前私有作用域中,有引用数据类型被外界所占用,导致当前作用域变成一个不销毁的作用域,里面的变量就成了不销毁的变量 一般情况下,函数执行完成后, 当前作用域就会销毁 函数每执行一次就会开辟一个新的私有作用域, 并且新的私有作用域和之前的作用域没有任何关系, 是两个不同的栈内存 不销毁的作用域 : 函数执行return出一个引用的数据类型的值 函数执行return 出的引用数据类型值并且被外界接收( 被占用 ) 堆内存 浏览器加载的时候,碰到引用数据类型,都会开辟一个新的内存空间,[对象 : 键值对 ,函数 : 代码字符串],给这个内存空间赋一个16进制内存地址,将这个内存地址指向声明的变量,这个内存空间就是堆内存 堆内存的释放,手动 null , [指向空指针] ; 浏览器判断该内存没有变量去接收它 ,就会释放 123456789function fn() &#123; var t = 10; return function () &#123; console.log(t) &#125; &#125;;var f = fn();f()f() 不立即销毁: 需要等到里面的小函数执行完成之后,那么外层作用域就会销毁 1234567function fn() &#123; var t = 10; return function () &#123; console.log(t) &#125; &#125;; fn()(); 123456789101112var i =0; function fn(i) &#123; // i =5 6 return function (n) &#123; console.log(n + i++); &#125; &#125;;var f = fn(5);f(10);// 15f(20);// 26fn(8)(12);// 20fn()(18)// NaN 123456789101112function fn ()&#123; var a = 1 ; return function ()&#123; a++; console.log(a); &#125;&#125;var f = fn();f(); //2fn()(); //2f(); //3 1234567891011121314var obj= &#123; i : 10, fn:(function () &#123; var i = 0; return function (n) &#123; console.log(n + i++) &#125; &#125;)() &#125;; var f = obj.fn; f(10);// 10 f(20);// 21 obj.fn(30);// 32 块级作用域 obj.fn(40);// 43 块级作用域for 循环中用let ,会形成父作用域；每循环一次，都会形成一个子作用域；在子作用域中会把当前的i进行保存 this 关键字在作用域下有特殊意义 函数中的this,指的就是函数的当前执行主体 在全局作用域下, this指向window; 函数体中的this,看函数执行前有没有”.” ; 如果有,那么点前面是谁,this就指向谁,如果没有” . “ ; 那么会指向window; 如果给元素的事件行为绑定方法,那么方法中的this,就会指向当前被绑定的那个元素 回调函数中this指向window(函数作为实参传进去) 自执行函数中的this永远都指向window forEach map 第二个参数可以修改this this是谁,和它在哪定义的以及在哪执行的没有任何关系 构造函数中的this 指向当前类的实例 call apply blind 可以改变this关键字 1234567891011121314151617181920212223242526272829function b() &#123; console.log(this); //window &#125; window.b(); var obj = &#123; num:1, fn : function () &#123; console.log(this); function m() &#123; console.log(this);// window; &#125; m() &#125; &#125; var f = obj.fn; f(); // window obj.fn();// obj var obj = &#123; num:1, f:&#123; num:2, fn:function () &#123; console.log(this);// obj.f &#125; &#125; &#125; obj.f.fn() 12345678910111213141516171.setInterval(function () &#123; console.log(this); // window &#125;,1000)2.(function () &#123; console.log(this); //window &#125;)()3.var obj = &#123; fn: (function () &#123; console.log(this); //window &#125;)() &#125; 12345678910111213141516var num =2;// 1 2 var obj = &#123; num : 0, fn : function () &#123; num = 1; // this--&gt;obj (function (num) &#123; // this --&gt; window ++this.num; num++; console.log(num)// 1 &#125;)(this.num)// 0 &#125; &#125; obj.fn(); console.log(window.num,obj.num) //2 0 this 重点练习题12345678910111213141516var num =2;// 1 2 var obj = &#123; num : 0, fn : function () &#123; num = 1; // this--&gt;obj (function (num) &#123; // this --&gt; window ++this.num; num++; console.log(num)// 1 &#125;)(this.num)// 0 &#125; &#125; obj.fn(); console.log(window.num,obj.num) //2 0","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lingkeyu.com/categories/javascript/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"},{"name":"基础知识","slug":"基础知识","permalink":"http://lingkeyu.com/tags/基础知识/"}]},{"title":"个人知识总结(一)","slug":"个人知识总结(一)","date":"2017-08-12T03:12:41.000Z","updated":"2018-09-01T13:04:40.579Z","comments":true,"path":"2017/08/12/个人知识总结(一)/","link":"","permalink":"http://lingkeyu.com/2017/08/12/个人知识总结(一)/","excerpt":"个人知识总结(一) webstorm : 代码编译器 浏览器 : 代码解析器; Git : 是一个工具; 用于团队协作开发项目管理代码的工具 svn : 集中式 需要一个中央服务器;每次开发前需要从中央服务器中把最新的代码拉取出来,然后进行开发,并且需要网络; Git : 分布式 每个人的电脑都是一个中央服务器","text":"个人知识总结(一) webstorm : 代码编译器 浏览器 : 代码解析器; Git : 是一个工具; 用于团队协作开发项目管理代码的工具 svn : 集中式 需要一个中央服务器;每次开发前需要从中央服务器中把最新的代码拉取出来,然后进行开发,并且需要网络; Git : 分布式 每个人的电脑都是一个中央服务器 Dos命令 按住shift 右键,打开powerShell 找到相应文件夹,直接输入cmd window + R : 输入cmd 切换此盘路径cd + 文件夹名字 : 打开相应路径cd .. / : 返回上一级cd / : 返回根目录cls : 清屏mkdir + 文件名 : 创建文件夹 Git配置Git用户名和密码 git config –global user.email “邮箱” git config –global user.name “用户名” git init : 初始化一个git 仓库git add . : 把文件添加到暂存区git add [文件名] 推送指定文件到暂存区git commit -m “注释” : 把代码提交到历史区 会生成一个版本号,可以根据版本号回到任何一次修改的位置git status : 查看文件状态;如果文件只存在本地,不在暂存区,那么颜色是红色,如果文件在缓存区,还没到历史区,那么颜色是绿色的本地代码—-&gt; 暂存区 —&gt; 历史区; git : 初始一个本地仓库gitHub : 是一个开源网站,可以供大家分享代码 插件和框架把本地的代码提交到远程仓库(gitHub)让本地仓库和远程仓库进行绑定 git remote add origin(仓库名) 远程仓库地址 : 将本地仓库和远程仓库建立连接git remote -v : 查看本地仓库和远程仓库关联状态git push origin(仓库名) master : 将历史区内容推送到远程仓库 master :主分支名 git config –list : 查看本地配置环境输入用户名和密码 推送过程(步骤)git initgit add .git statusgit commit -m “里面注释” git remote add origin(仓库名) 地址git remote -vgit push origin(仓库名) master 推送复原过程 拉取克隆过程(步骤)git clone 仓库地址 : 已经是一个git仓库, 且和远程仓库建立了连接 git pull origin master : 拉取远程仓库代码 作用域 作用域：代码执行的空间/环境 ===栈内存 浏览器的渲染机制 : 先形成一个DOM树和CSS树,最后两个树合成render树 全局作用域：打开浏览器就会形成的全局作用域 存储基本数据类型值 基本数据类型存储到栈内存中,全局作用域是最大的一个栈内存 window 是全局中最大的一个对象, 存储了大量内置属性 typeof window —&gt; object 私有作用域：一个函数执行就会形成一个私有作用域 关闭浏览器就销毁块作用域：ES6新增加的，除了私有作用域和对象以外被一个{}包起来的，eval(“({a:1})”)； 全局变量: 在全局作用域下定义的变量会给window 新增一个键值对 全局下定义的函数相当于给window新增键值对,属性名是函数,属性值整个函数 私有变量在函数体中被var,和function,const,let过 函数的形参也是私有变量 性能优化1234567891011121314151617181920212223242526272829301.-function fn() &#123; var total = 0; var len = arguments.length; // (var i=0;i&lt;arguments.length;i++) for(var i=0;i&lt;len;i++)&#123; var cur = arguments[i]; if(!isNaN(cur))&#123; // total += arguments[i]; total +=cur; &#125; &#125;2.- function fn()&#123;&#125;console.log(\"fn\" in window);//true//`fn`必须加引号 3.-var a,b,fn = function () &#123; var a= b =10; // ( var a= b =10; --&gt; var a=10;b = 10;) // a变成了局部变量无法修改外部,b成了全局变量,修改了外部 &#125; fn(); console.log(a,b);// undefined 10","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lingkeyu.com/categories/javascript/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"},{"name":"基础知识","slug":"基础知识","permalink":"http://lingkeyu.com/tags/基础知识/"}]},{"title":"秒懂JS中的盒模型~~","slug":"秒懂JS中的盒模型","date":"2017-07-23T11:32:41.000Z","updated":"2018-09-01T13:04:53.631Z","comments":true,"path":"2017/07/23/秒懂JS中的盒模型/","link":"","permalink":"http://lingkeyu.com/2017/07/23/秒懂JS中的盒模型/","excerpt":"首先要明白什么是JS盒子模型???JS盒模型 指的是通过JS中提供的一系列的属性和方法,获取页面中元素的样式信息值 #box(有很多自己的私有的属性) -&gt;HTMLDivElement.prototype -&gt;HTMLElement.prototype -&gt;Element.prototype -&gt;Node.prototype -&gt;EventTarget.prototype -&gt;Object.prototype var box = document.getElementById(“box”); console.dir(box);","text":"首先要明白什么是JS盒子模型???JS盒模型 指的是通过JS中提供的一系列的属性和方法,获取页面中元素的样式信息值 #box(有很多自己的私有的属性) -&gt;HTMLDivElement.prototype -&gt;HTMLElement.prototype -&gt;Element.prototype -&gt;Node.prototype -&gt;EventTarget.prototype -&gt;Object.prototype var box = document.getElementById(“box”); console.dir(box); 内容的宽度和高度:我们设置的width/height这两个样式就是内容的宽和高;如果没有设置height值,容器的高度会根据里面内容自己进行适应,这样获取的值就是真实内容的高;如果设置固定的高度了,不管内容是多了还是少了,其实我们内容的高度指的都是设定的那个值; 真实内容的宽度和高度:这个代指的是实际内容个的宽高(和我们设置的height没有必然的联系),例如:我设置高度为200px,如果内容有溢出,那么真实内容的高度是要把溢出内容的高度也要加进来的 12345678910111213141516171819202122232425262728293031323334351、client系列(当前元素的几个私有的属性) clientWidth/clientHeight:内容的宽度/高度+左右/上下填充 (和内容溢出没有关系) clientLeft:左边框的宽度 clientTop:上边框的高度 (border[Left/Top]Width) 2、offset系列 offsetWidth/offsetHeight:clientWidth/clientHeight+左右/上下边框 (和内容是否溢出也是没有任何的关系的) offsetParent:当前元素的父级参照物 offsetLeft/offsetTop:当前元素的外边框距离父级参照物的内边框的偏移量 3、scroll系列 scrollWidth/scrollHeight:和我们的clientWidth/clientHeight一模一样(前提是：容器中的内容没有溢出的情况下) 如果容器中的内容有溢出,我们获取的结果是如下规则: scrollWidth:真实内容的宽度(包含溢出)+左填充 scrollHeight:真实内容的高度(包含溢出)+上填充获取到的结果都是\"约等于\"的值,因为:同一个浏览器,我们是否设置overflow='hidden'对于最终的结果是有影响的;在不同的浏览器中我们获取到的结果也是不相同的; scrollLeft/scrollTop:滚动条卷去的宽度/高度 2、关于JS盒子模型属性取值的问题 我们通过这13个属性值获取的结果永远不可能出现小数,都是整数;浏览器获取结果的时候,在原来真实结果的基础上进行四舍五入; 3、关于操作浏览器本身的盒子模型信息 clientWidth/clientHeight是当前浏览器可视窗口的宽度和高度(一屏幕的宽度和高度) scrollWidth/scrollHeight是当前页面的真实宽度和高度(所有屏加起来的宽度和高度~但是是一个约等于的值 我们不管哪些属性,也不管是什么浏览器,也不管是获取还是设置,想要都兼容的话,需要写两套 document.documentElement[attr]||document.body[attr]; //-&gt;必须document.documentElement在前 例如： [获取] document.documentElement.clientWidth||document.body.clientWidth [设置也需要写两套] document.documentElement.scrollTop=0; document.body.scrollTop=0; 12345678910function win(attr, value) &#123; if (typeof value === \"undefined\") &#123;//-&gt;没有传递value值-&gt;\"获取\" return document.documentElement[attr] || document.body[attr]; &#125; //-&gt;\"设置\" document.documentElement[attr] = value; document.body[attr] = value;&#125;console.log(win(\"clientHeight\"));win(\"scrollTop\", 0); win:一个有关于操作浏览器盒子模型的方法 如果只传递了attr没有传递value,默认的意思是“获取” 如果两个参数都传递了,意思是“设置” 不严谨的来说这就是有关于”类的重载”:同一个方法,通过传递参数的不同实现了不同的功能JS盒子模型中:client系列/offset系列/scrollWidth/scrollHeight都是”只读”属性-&gt;只能通过属性获取值,不能通过属性修改元素的样式 scrollTop/scrollLeft:滚动条卷去的高度/宽度(这两个属性是唯一”可读写”属性) //box.scrollTop = 0;//-&gt;直接回到了容器的顶部 我们的scrollTop的值是存在边界值(最大和最小值的),我们设置的值比最小值小或者比最大值大都没用,起到效果的依然是边界的值 1234567[最小值是零] box.scrollTop = -1000;//-&gt;直接回到了容器的顶部,没有超出 console.log(box.scrollTop);//-&gt;0[最大值是=真实的高度-当前容器一屏幕的高度] var maxTop = box.scrollHeight - box.clientHeight; console.log(maxTop);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lingkeyu.com/categories/javascript/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"}]},{"title":"数组的方法汇集+解析","slug":"数组的方法汇集+解析","date":"2017-07-20T01:02:31.000Z","updated":"2018-09-01T13:05:03.343Z","comments":true,"path":"2017/07/20/数组的方法汇集+解析/","link":"","permalink":"http://lingkeyu.com/2017/07/20/数组的方法汇集+解析/","excerpt":"数组的方法汇集+解析数组方法的运用,在实际的项目真的是涉及到很多,熟练运用好数组的方法,可以帮我们轻松解决掉很多问题,那么数组的方法有哪些? 我特意去收集查找了一下,码了下来…..","text":"数组的方法汇集+解析数组方法的运用,在实际的项目真的是涉及到很多,熟练运用好数组的方法,可以帮我们轻松解决掉很多问题,那么数组的方法有哪些? 我特意去收集查找了一下,码了下来…..创建一个数组: // 字面量方式: // 这个方法也是我们最常用的，在初始化数组的时候 相当方便 var a = [3, 11, 8]; // [3,11,8]; // 构造器: // 实际上 new Array === Array,加不加new 一点影响都没有。 var a = Array(); // [] var a = Array(3); // [,,] var a = Array(3,11,8); // [ 3,11,8 ] ES6 Array.of() 返回由所有参数值组成的数组定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。 let a = Array.of(3, 11, 8); // [3,11,8] let a = Array.of(3); // [3] ES6 Arrary.from() 将两类对象转为真正的数组定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。参数：第一个参数(必需):要转化为真正数组的对象。第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。第三个参数(可选): 用来绑定this。 // 1. 对象拥有length属性 let obj = {0: ‘a’, 1: ‘b’, 2:’c’, length: 3}; let arr = Array.from(obj); // [‘a’,’b’,’c’]; // 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象 let arr = Array.from(‘hello’); // [‘h’,’e’,’l’,’l’,’o’] let arr = Array.from(new Set([‘a’,’b’])); // [‘a’,’b’] 方法:数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。改变原数组的方法(9个): let a = [1,2,3]; ES5: a.splice()/ a.sort() / a.pop()/ a.shift()/ a.push()/ a.unshift()/ a.reverse() ES6: a.copyWithin() / a.fill 对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。splice() 添加/删除数组元素定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目语法： array.splice(index,howmany,item1,…..,itemX)参数:index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX： 可选。向数组添加的新项目。返回值: 如果有元素被删除,返回包含被删除项目的新数组。eg1:删除元素 let a = [1, 2, 3, 4, 5, 6, 7]; let item = a.splice(0, 3); // [1,2,3] console.log(a); // [4,5,6,7] // 从数组下标0开始，删除3个元素 let item = a.splice(-1, 3); // [7] // 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7 eg2: 删除并添加 let a = [1, 2, 3, 4, 5, 6, 7]; let item = a.splice(0,3,’添加’); // [1,2,3] console.log(a); // [‘添加’,4,5,6,7] // 从数组下标0开始，删除3个元素，并添加元素’添加’ let b = [1, 2, 3, 4, 5, 6, 7]; let item = b.splice(-2,3,’添加1’,’添加2’); // [6,7] console.log(b); // [1,2,3,4,5,’添加1’,’添加2’] // 从数组最后第二个元素开始，删除3个元素，并添加两个元素’添加1’、’添加2’ eg3: 不删除只添加: let a = [1, 2, 3, 4, 5, 6, 7]; let item = a.splice(0,0,’添加1’,’添加2’); // [] 没有删除元素，返回空数组 console.log(a); // [‘添加1’,’添加2’,1,2,3,4,5,6,7] let b = [1, 2, 3, 4, 5, 6, 7]; let item = b.splice(-1,0,’添加1’,’添加2’); // [] 没有删除元素，返回空数组 console.log(b); // [1,2,3,4,5,6,’添加1’,’添加2’,7] 在最后一个元素的前面添加两个元素 从上述三个栗子可以得出:数组如果元素不够，会删除到最后一个元素为止操作的元素，包括开始的那个元素可以添加很多个元素添加是在开始的元素前面添加的sort() 数组排序定义: sort()方法对数组元素进行排序，并返回这个数组。参数可选: 规定排序顺序的比较函数。默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 // 字符串排列 看起来很正常 var a = [“Banana”, “Orange”, “Apple”, “Mango”]; a.sort(); // [“Apple”,”Banana”,”Mango”,”Orange”] // 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的 var a = [10, 1, 3, 20,25,8]; console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数：sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：若比较函数返回值&lt;0，那么a将排到b的前面;若比较函数返回值=0，那么a 和 b 相对位置不变；若比较函数返回值&gt;0，那么b 排在a 将的前面；sort排序常见用法：数组元素为数字的升序、降序: var array = [10, 1, 3, 4,20,4,25,8]; // 升序 a-b &lt; 0 a将排到b的前面，按照a的大小来排序的 // 比如被减数a是10，减数是20 10-20 &lt; 0 被减数a(10)在减数b(20)前面 array.sort(function(a,b){ return a-b; }); console.log(array); // [1,3,4,4,8,10,20,25]; // 降序 被减数和减数调换了 20-10&gt;0 被减数b(20)在减数a(10)的前面 array.sort(function(a,b){ return b-a; }); console.log(array); // [25,20,10,8,4,4,3,1]; 数组多条件排序 var array = [{id:10,age:2},{id:5,age:4},{id:6,age:10},{id:9,age:6},{id:2,age:8},{id:10,age:9}]; array.sort(function(a,b){ if(a.id === b.id){// 如果id的值相等，按照age的值降序 return b.age - a.age }else{ // 如果id的值不相等，按照id的值升序 return a.id - b.id } }) // [{“id”:2,”age”:8},{“id”:5,”age”:4},{“id”:6,”age”:10},{“id”:9,”age”:6},{“id”:10,”age”:9},{“id”:10,”age”:2}] 自定义比较函数，天空才是你的极限类似的：运用好返回值，我们可以写出任意符合自己需求的比较函数 var array = [{name:’Koro1’},{name:’Koro1’},{name:’OB’},{name:’Koro1’},{name:’OB’},{name:’OB’}]; array.sort(function(a,b){ if(a.name === ‘Koro1’){// 如果name是’Koro1’ 返回-1 ，-1&lt;0 a排在b的前面 return -1 }else{ // 如果不是的话，a排在b的后面 return 1 } }) // [{“name”:”Koro1”},{“name”:”Koro1”},{“name”:”Koro1”},{“name”:”OB”},{“name”:”OB”},{“name”:”OB”}] pop() 删除一个数组中的最后的一个元素定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。参数: 无。 let a = [1,2,3]; let item = a.pop(); // 3 console.log(a); // [1,2] shift() 删除数组的第一个元素定义: shift()方法删除数组的第一个元素，并返回这个元素。参数: 无。 let a = [1,2,3]; let item = a.shift(); // 1 console.log(a); // [2,3] push() 向数组的末尾添加元素定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。参数: item1, item2, …, itemX ,要添加到数组末尾的元素 let a = [1,2,3]; let item = a.push(‘末尾’); // 4 console.log(a); // [1,2,3,’末尾’] unshift()定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。参数: item1, item2, …, itemX ,要添加到数组开头的元素 let a = [1,2,3]; let item = a.unshift(‘开头’); // 4 console.log(a); // [‘开头’,1,2,3] reverse() 颠倒数组中元素的顺序定义: reverse() 方法用于颠倒数组中元素的顺序。参数: 无 let a = [1,2,3]; a.reverse(); console.log(a); // [3,2,1] ES6: copyWithin() 指定位置的成员复制到其他位置定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。语法: array.copyWithin(target, start = 0, end = this.length) 参数:三个参数都是数值，如果不是，会自动转为数值.target（必需）：从该位置开始替换数据。如果为负值，表示倒数。start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持eg: // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] var a=[‘OB1’,’Koro1’,’OB2’,’Koro2’,’OB3’,’Koro3’,’OB4’,’Koro4’,’OB5’,’Koro5’] // 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换 a.copyWithin(2,3,5) // [“OB1”,”Koro1”,”Koro2”,”OB3”,”OB3”,”Koro3”,”OB4”,”Koro4”,”OB5”,”Koro5”] 从上述栗子:第一个参数是开始被替换的元素位置要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取数组的长度不会改变读了几个元素就从开始被替换的地方替换几个元素ES6: fill() 填充数组定义: 使用给定值，填充一个数组。参数:第一个元素(必须): 要填充数组的值第二个元素(可选): 填充的开始位置,默认值为0第三个元素(可选)：填充的结束位置，默认是为this.length ['a', 'b', 'c'].fill(7) // [7, 7, 7] ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 不改变原数组的方法(8个): ES5： slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf、 ES7： includes slice() 浅拷贝数组的元素 定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 注意：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。 语法: array.slice(begin, end); 参数: begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。 end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。 let a= ['hello','world']; let b=a.slice(0,1); // ['hello'] a[0]='改变原数组'; console.log(a,b); // ['改变原数组','world'] ['hello'] b[0]='改变拷贝的数组'; console.log(a,b); // ['改变原数组','world'] ['改变拷贝的数组'] 如上：新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。 let a= [{name:'OBKoro1'}]; let b=a.slice(); console.log(b,a); // [{\"name\":\"OBKoro1\"}] [{\"name\":\"OBKoro1\"}] // a[0].name='改变原数组'; // console.log(b,a); // [{\"name\":\"改变原数组\"}] [{\"name\":\"改变原数组\"}] // b[0].name='改变拷贝数组',b[0].koro='改变拷贝数组'; // [{\"name\":\"改变拷贝数组\",\"koro\":\"改变拷贝数组\"}] [{\"name\":\"改变拷贝数组\",\"koro\":\"改变拷贝数组\"}] 原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。 join() 数组转字符串 定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 参数: str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。 let a= ['hello','world']; let str=a.join(); // 'hello,world' let str2=a.join('+'); // 'hello+world' 使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？ let a= [['OBKoro1','23'],'test']; let str1=a.join(); // OBKoro1,23,test let b= [{name:'OBKoro1',age:'23'},'test']; let str2 = b.join(); // [object Object],test // 对象转字符串推荐JSON.stringify(obj); 所以，join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),如果是对象的话，对象会被转为[object Object]字符串。 toLocaleString() 数组转字符串 定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 语法: array.toLocaleString() 参数：无。 let a=[{name:'OBKoro1'},23,'abcd',new Date()]; let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 如上述栗子：调用数组的toLocaleString方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。 toString() 数组转字符串 不推荐 定义: toString() 方法可把数组转换为由逗号链接起来的字符串。 语法: array.toString() 参数: 无。 该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。 值得注意的是：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串 let b= [ 'toString','演示'].toString(); // toString,演示 let a= ['调用toString','连接在我后面']+'啦啦啦'; // 调用toString,连接在我后面啦啦啦 cancat 定义： 方法用于合并两个或多个数组，返回一个新数组。 语法： var newArr =oldArray.concat(arrayX,arrayX,......,arrayX) arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。eg1: let a = [1, 2, 3]; let b = [4, 5, 6]; //连接两个数组 let newVal=a.concat(b); // [1,2,3,4,5,6] // 连接三个数组 let c = [7, 8, 9] let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9] // 添加元素 let newVal3 = a.concat(‘添加元素’,b, c,’再加一个’); // [1,2,3,”添加元素”,4,5,6,7,8,9,”再加一个”] // 合并嵌套数组 会浅拷贝嵌套数组 let d = [1,2 ]; let f = [3,[4]]; let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符…合并数组：因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用…来处理，…运算符可以实现cancat的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。 let a = [2, 3, 4, 5] let b = [ 4,…a, 4, 4] console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] indexOf() 查找数组是否存在某个元素，返回下标定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。语法: array.indexOf(searchElement,fromIndex) 参数:searchElement(必须):被查找的元素fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。严格相等的搜索:数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。注意：indexOf()不能识别NaNeg: let a=[‘啦啦’,2,4,24,NaN] console.log(a.indexOf(‘啦’)); // -1 console.log(a.indexOf(‘NaN’)); // -1 console.log(a.indexOf(‘啦啦’)); // 0 使用场景：数组去重根据获取的数组下标执行操作，改变数组中的值等。判断是否存在，执行操作。lastIndexOf() 查找指定元素在数组中的最后一个位置定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）语法: arr.lastIndexOf(searchElement,fromIndex) 参数:searchElement(必须): 被查找的元素fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。关于fromIndex有三个规则:正值。如果该值大于或等于数组的长度，则整个数组会被查找。负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 let a=[‘OB’,4,’Koro1’,1,2,’Koro1’,3,4,5,’Koro1’]; // 数组长度为10 // let b=a.lastIndexOf(‘Koro1’,4); // 从下标4开始往前找 返回下标2 // let b=a.lastIndexOf(‘Koro1’,100); // 大于或数组的长度 查找整个数组 返回9 // let b=a.lastIndexOf(‘Koro1’,-11); // -1 数组不会被查找 let b=a.lastIndexOf(‘Koro1’,-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔定义： 返回一个布尔值，表示某个数组是否包含给定的值语法： array.includes(searchElement,fromIndex=0) 参数：searchElement(必须):被查找的元素fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。includes方法是为了弥补indexOf方法的缺陷而出现的:indexOf方法不能识别NaNindexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观eg: let a=[‘OB’,’Koro1’,1,NaN]; // let b=a.includes(NaN); // true 识别NaN // let b=a.includes(‘Koro1’,100); // false 超过数组长度 不搜索 // let b=a.includes(‘Koro1’,-3); // true 从倒数第三个元素开始搜索 // let b=a.includes(‘Koro1’,-100); // true 负值绝对值超过数组长度，搜索整个数组 兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。遍历方法(12个):js中遍历数组并不会改变原始数组的方法总共有12个: ES5： forEach、every 、some、 filter、map、reduce、reduceRight、 ES6： find、findIndex、keys、values、entries 关于遍历：尽量不要在遍历的时候，修改后面要遍历的值尽量不要在遍历的时候修改数组的长度（删除/添加）forEach定义: 按升序为数组中含有效值的每一项执行一次回调函数。语法： array.forEach(function(currentValue, index, arr), thisValue) 参数:function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined关于forEach()你要知道：无法中途退出循环，只能用return退出本次回调，进行下一次回调。它总是返回 undefined值,即使你return了一个值。下面类似语法同样适用这些规则 1. 对于空数组是不会执行回调函数的 2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。 4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。 eg: let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历) let obj = { name: ‘OBKoro1’ }; let result = a.forEach(function (value, index, array) { a[3] = ‘改变元素’; a.push(‘添加到尾端，不会被遍历’) console.log(value, ‘forEach传递的第一个参数’); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log(‘不会执行，因为return 会执行下一次循环回调’) }, obj); console.log(result); // 即使return了一个值,也还是返回undefined // 回调函数也接受接头函数写法 every 检测数组所有元素是否都符合判断条件定义: 方法用于检测数组所有元素是否都符合函数定义的条件语法： array.every(function(currentValue, index, arr), thisValue) 参数:(这几个方法的参数，语法都类似)function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined方法返回值规则:如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。=eg: function isBigEnough(element, index, array) { return element &gt;= 10; // 判断数组中的所有元素是否都大于10 } let result = [12, 5, 8, 130, 44].every(isBigEnough); // false let result = [12, 54, 18, 130, 44].every(isBigEnough); // true // 接受箭头函数写法 [12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false [12, 54, 18, 130, 44].every(x =&gt; x &gt;= 10); // true some 数组中的是否有满足判断条件的元素定义：数组中的是否有满足判断条件的元素语法： array.some(function(currentValue, index, arr), thisValue) 参数:(这几个方法的参数，语法都类似)function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined方法返回值规则：如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。 function isBigEnough(element, index, array) { return (element &gt;= 10); //数组中是否有一个元素大于 10 } let result = [2, 5, 8, 1, 4].some(isBigEnough); // false let result = [12, 5, 8, 1, 4].some(isBigEnough); // true filter 过滤原始数组，返回新数组定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。语法： let new_array = arr.filter(function(currentValue, index, arr), thisArg) 参数:(这几个方法的参数，语法都类似)function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefinedeg: let a = [32, 33, 16, 40]; let result = a.filter(function (value, index, array) { return value &gt;= 18; // 返回a数组中所有大于18的元素 }); console.log(result,a);// [32,33,40] [32,33,16,40] map 对数组中的每个元素进行处理，返回新的数组定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。语法： let new_array = arr.map(function(currentValue, index, arr), thisArg) 参数:(这几个方法的参数，语法都类似)function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefinedeg:let a = [‘1’,’2’,’3’,’4’];let result = a.map(function (value, index, array) { return value + ‘新数组的新元素’});console.log(result, a);// [“1新数组的新元素”,”2新数组的新元素”,”3新数组的新元素”,”4新数组的新元素”] [“1”,”2”,”3”,”4”] reduce 为数组提供累加器，合并为一个值定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 参数：function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. total(必须)，初始值, 或者上一次调用回调返回的值 2. currentValue(必须),数组当前元素的值 3. index(可选), 当前元素的索引值 4. arr(可选),数组对象本身 initialValue(可选): 指定第一次回调 的第一个参数。回调第一次执行时:如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。eg: // 数组求和 let sum = [0, 1, 2, 3].reduce(function (a, b) { return a + b; }, 0); // 6 // 将二维数组转化为一维 将数组元素展开 let flattened = [[0, 1], [2, 3], [4, 5]].reduce( (a, b) =&gt; a.concat(b), [] ); // [0, 1, 2, 3, 4, 5] reduceRight 从右至左累加这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。ES6：find()&amp; findIndex() 根据条件找到数组成员find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。这两个方法语法： let new_array = arr.find(function(currentValue, index, arr), thisArg) let new_array = arr.findIndex(function(currentValue, index, arr), thisArg) 参数:(这几个方法的参数，语法都类似)function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined这两个方法都可以识别NaN,弥补了indexOf的不足.eg: // find let a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5 let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN // findIndex let a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2 let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4 浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。语法： array.keys() array.values() array.entries() 参数：无。 for (let index of ['a', 'b'].keys()) { console.log(index); } // 0 // 1 for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' // 'b' for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); } // 0 \"a\" // 1 \"b\" 在for..of中如果遍历中途要退出，可以使用break退出循环。 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历: let letter = ['a', 'b', 'c']; let entries = letter.entries(); console.log(entries.next().value); // [0, 'a'] console.log(entries.next().value); // [1, 'b'] console.log(entries.next().value); // [2, 'c']","categories":[{"name":"数组","slug":"数组","permalink":"http://lingkeyu.com/categories/数组/"},{"name":"javascript","slug":"数组/javascript","permalink":"http://lingkeyu.com/categories/数组/javascript/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"前端学习","slug":"前端学习","permalink":"http://lingkeyu.com/tags/前端学习/"}]},{"title":"Android四大组件知识点","slug":"Android四大组件知识点","date":"2017-04-19T03:02:11.000Z","updated":"2018-09-01T13:04:08.285Z","comments":true,"path":"2017/04/19/Android四大组件知识点/","link":"","permalink":"http://lingkeyu.com/2017/04/19/Android四大组件知识点/","excerpt":"Android四大组件知识点分别为activity、service、content provider、broadcast receiver。","text":"Android四大组件知识点分别为activity、service、content provider、broadcast receiver。 一、android四大组件详解 1、Activity （1）一个Activity通常就是一个单独的屏幕（窗口），它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 （2）Activity之间通过Intent进行通信。 （3）android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。 2、Service （1）service用于在后台完成用户指定的操作。service分为两种：（a）started（启动）：当应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态。（b）bound（绑定）：当应用程序组件调用bindService()方法绑定到服务时，服务处于bound状态。 (2)startService()与bindService()区别：(a)started service（启动服务）是由其他组件调用startService()方法启动的，这导致服务的onStartCommand()方法被调用。当服务是started状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用stopSelf()方法停止，或者由其他组件调用stopService()方法停止。 (b)使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 (3)开发人员需要在应用程序配置文件中声明全部的service，使用标签。 (4)Service通常位于后台运行，它一般不需要与用户交互，因此Service组件没有图形用户界面。Service组件需要继承Service基类。Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 3、Content Psrovider （1）android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。 （2）只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。（3）ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。 （4）开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作。 （5）ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理。 4、Broadcast Receiver （1）你的应用可以使用它对外部事件进行过滤，只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 （2）广播接收者的注册有两种方法，分别是程序动态注册和AndroidManifest文件中进行静态注册。 （3）动态注册广播接收器特点是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕app本身未启动，该app订阅的广播在触发时也会对它起作用。 二、android四大组件总结： （1）4大组件的注册 4大基本组件都需要注册才能使用，每个Activity、service、Content Provider都需要在AndroidManifest文件中进行配置。AndroidManifest文件中未进行声明的activity、服务以及内容提供者将不为系统所见，从而也就不可用。而broadcast receiver广播接收者的注册分静态注册（在AndroidManifest文件中进行配置）和通过代码动态创建并以调用Context.registerReceiver()的方式注册至系统。需要注意的是在AndroidManifest文件中进行配置的广播接收者会随系统的启动而一直处于活跃状态，只要接收到感兴趣的广播就会触发（即使程序未运行）。 （2）4大组件的激活 内容提供者的激活：当接收到ContentResolver发出的请求后，内容提供者被激活。而其它三种组件activity、服务和广播接收器被一种叫做intent的异步消息所激活。 （3）4大组件的关闭 内容提供者仅在响应ContentResolver提出请求的时候激活。而一个广播接收器仅在响应广播信息的时候激活。所以，没有必要去显式的关闭这些组件。Activity关闭：可以通过调用它的finish()方法来关闭一个activity。服务关闭：对于通过startService()方法启动的服务要调用Context.stopService()方法关闭服务，使用bindService()方法启动的服务要调用Context.unbindService()方法关闭服务。 （4）android中的任务（activity栈） （a）任务其实就是activity的栈，它由一个或多个Activity组成，共同完成一个完整的用户体验。栈底的是启动整个任务的Activity，栈顶的是当前运行的用户可以交互的Activity，当一个activity启动另外一个的时候，新的activity就被压入栈，并成为当前运行的activity。而前一个activity仍保持在栈之中。当用户按下BACK键的时候，当前activity出栈，而前一个恢复为当前运行的activity。栈中保存的其实是对象，栈中的Activity永远不会重排，只会压入或弹出。 （b）任务中的所有activity是作为一个整体进行移动的。整个的任务（即activity栈）可以移到前台，或退至后台。 （c）Android系统是一个多任务(Multi-Task)的操作系统，可以在用手机听音乐的同时，也执行其他多个程序。每多执行一个应用程序，就会多耗费一些系统内存，当同时执行的程序过多，或是关闭的程序没有正确释放掉内存，系统就会觉得越来越慢，甚至不稳定。为了解决这个问题，Android引入了一个新的机制，即生命周期(Life Cycle)。 Activity的生命周期：1.七大生命周期：onCreate() 第一次创建时执行;onStart() 显示窗口时执行;onResume() 可获取用户焦点时执行;onPause() 失去用户焦点时执行;onStop() 关闭窗口时执行;onRestart() 重新显示窗口时执行;onDestroy() 销毁时执行; 2.各种情况下生命周期的回调规律： （1）应用程序进来主页面后：onCreate() 创建activity时onStart () 启动时onResume() 显示时 （2) 按返回退出后： 123onPause() 暂停时 --&gt;丧失用户焦点的第一个特征onStop() 停止时onDestroy() 销毁时 （3）按home后： 12onPause() 暂停时 onStop() 停止时 （4）在home页再次点击这个应用： 123onRestart() onStart() 启动时onResume () 显示时 （5）切换成横屏后： 123456onPause() 暂停时 onStop() 停止时onDestroy() 销毁时onCreate() 创建activity时onStart() 启动时onResume() 显示时 注意设置 Activity 的 android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行 onConfigurationChanged 方法 三、Activity的启动模式： 第一：什么是启动模式，启动的模式，理解成一个activity的启动的方式。分为四种： 1、首先，我们现在没有指定任何启动模式，叫默认模式（standard）标准的启动模式，每次激活activity时都会创建activity，创建之后，会把它放到任务栈里。 2、singleTop如果在任务的栈顶，就重用该实例，如果栈顶不是这个activity，就重新实例化一个activity放到栈顶。 3、singleTask如果在栈中已经有该activity的实例，就重复使用该实例，并且把压在它上边的实例全都清除掉；如果在栈中没有找到该activity的实例，就创建一个放在栈顶。 4、singleInstance与singletask的区别是，存放singleinstance模式的activity的回退栈，不能有其他任何activity对象，也就是说，它自己单独有一个回退栈。 我们可以在 AndroidManifest.xml 配置的 android:launchMode 属性为以上四种之一即可 第二：两个 Activity 之间跳转时必然会执行的是哪几个方法？（重要） 一般情况下比如说有两个 activity,分别叫 A,B。当在 A 里面激活 B 组件的时候,A 会调用 onPause()方法,然后 B 调用 onCreate() ,onStart(), onResume()。这个时候 B 覆盖了窗体, A 会调用 onStop()方法. 如果 B 是个透明的,或者是对话框的样式, 就不会调用 A 的onStop()方法 第三：如何将一个 Activity 设置成窗口的样式？ 只需要给我们的 Activity 配置如下属性即可。android:theme=”@android:style/Theme.Dialog 第四：如何退出 Activity？如何安全退出已调用多个 Activity 的 Application？ 1、通常情况用户退出一个 Activity 只需按返回键，我们写代码想退出 activity 直接调用 finish()方法就行。 2、记录打开的 Activity：每打开一个 Activity，就记录下来。在需要退出时，关闭每一个 Activity 即可。//伪代码List lists ;// 在 application 全局的变量里面lists = new ArrayList();lists.add(this);for(Activity activity: lists){activity.finish();}lists.remove(this); 3、发送特定广播：在需要结束应用时，发送一个特定的广播，每个 Activity 收到广播后，关闭即可。//给某个 activity 注册接受接受广播的意图registerReceiver(receiver, filter)//如果过接受到的是 关闭 activity 的广播 就调用 finish()方法 把当前的 activity finish()掉 4、递归退出在打开新的 Activity 时使用 startActivityForResult，然后自己加标志，在 onActivityResult 中处理，递归关闭。 5、其实 也可以通过 intent 的 flag 来实现 intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) 激活一个新的 activity。此时如果该任务栈中已经有该 Activity，那么系统会把这个 Activity 上面的所有 Activity 干掉。其实相当于给 Activity 配置的启动模式为 SingleTop。 Service的知识点 第一：Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作? 默认情况,如果没有显示的指 service 所运行的进程, Service 和 activity 是运行在当前 app 所在进程的 mainthread(UI 主线程)里面。service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )特殊情况 ,可以在清单文件配置 service 执行所在的进程 ,让 service 在另外的进程中执行。 第二：请描述一下 Service 的生命周期 Service 有绑定模式和非绑定模式，以及这两种模式的混合使用方式。不同的使用方法生命周期方法也不同。非绑定模式：当第一次调用 startService 的时候执行的方法依次为 onCreate()、onStartCommand()， （onStart()）当 Service 关闭的时候调用 onDestory 方法。绑定模式：第一次 bindService（）的时候，执行的方法为 onCreate()、onBind(）解除绑定的时候会执行onUnbind()、onDestory()。 上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意 Service 实例只会有一个，也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会调用 onCreate（）方法。 一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了 onBind（）方法后该 Service 才会销毁，不过如果有一个客户执行了 onStart()方法，那么这个时候如果所有的 bind 客户都执行了 unBind()该 Service 也不会销毁。 第三：Service 的 onStartCommand 方法有几种返回值？各代表什么意思？ 有四种返回值，不同值代表的意思如下： （1）START_STICKY：如果 service 进程被 kill 掉，保留 service 的状态为开始状态，但不保留递送的 intent 对象。随后 系 统 会 尝 试 重 新 创 建 service ， 由 于 服 务 状 态 为 开 始 状 态 ，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到 service，那么参数 Intent 将为 null。 （2）START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完 onStartCommand 后，服务被异常 kill掉，系统不会自动重启该服务。 （3）START_REDELIVER_INTENT：重传 Intent。使用这个返回值时，如果在执行完 onStartCommand 后，服务被异常 kill 掉，系统会自动重启该服务，并将 Intent 的值传入。 （4）START_STICKY_COMPATIBILITY：START_STICKY 的兼容版本，但不保证服务被 kill 后一定能重启 第四：Service 的 onRebind（Intent）方法在什么情况下会执行？ 如果在 onUnbind（）方法返回 true 的情况下会执行，否则不执行。 ####BroadCastReceiverBroadCastReceiver 是 Android 四大组件之一，主要用于接收系统或者 app 发送的广播事件。 广播分两种：有序广播和无序广播。内部通信实现机制：通过 Android 系统的 Binder 机制实现通信。 无序广播：完全异步，逻辑上可以被任何广播接收者接收到。优点是效率较高。缺点是一个接收者不能将处理结果传递给下一个接收者，并无法终止广播 intent 的传播。 有序广播：按照被接收者的优先级顺序，在被接收者中依次传播。比如有三个广播接收者 A，B，C，优先级是 A &gt; B &gt; C。那这个消息先传给 A，再传给 B，最后传给 C。每个接收者有权终止广播，比如 B 终止广播，C 就无法接收到。此外 A 接收到广播后可以对结果对象进行操作，当广播传给 B 时，B 可以从结果对象中取得 A 存入的数据。在通过 Context.sendOrderedBroadcast(intent, receiverPermission, resultReceiver, scheduler, initialCode,initialData, initialExtras)时我们可以指定 resultReceiver 广播接收者，这个接收者我们可以认为是最终接收者，通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的 onReceive 会被执行两次，第一次是正常的按照优先级顺序执行，第二次是作为最终接收者接收。如果比他优先级高的接收者终止了广播，那么他依然能接收到广播。在我们的项目中经常使用广播接收者接收系统通知，比如开机启动、sd 挂载、低电量、外拨电话、锁屏等。如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放之暂停等。 BroadCastReceiver 的生命周期：a. 广播接收者的生命周期非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁；b. 广播接收者中不要做一些耗时的工作，否则会弹出 Application No Response 错误对话框；c. 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉；d. 耗时的较长的工作最好放在服务中完成； 第三：什么是最终广播接收者？ 最终广播是我们自己应用发送有序广播时通过 ContextWrapper.sendOrderedBroadcast()方法指定的当前应用下的广播，该广播可能会被执行两次，第一次是作为普通广播按照优先级接收广播，第二次是作为 final receiver 必须接收一次。 第四：广播的优先级对无序广播生效吗？—- 生效！！！！ 第五：动态注册的广播谁的优先级高？—– 谁先注册谁的优先级高！！ 第六：如何判断当前 BroadcastReceiver 接收到的是有序广播还是无序广播 ？ 在 BroadcastReceiver 类中 onReceive（）方法中，可以调用 boolean b = isOrderedBroadcast（）;该方法是BroadcastReceiver 类中提供的方法，用于告诉我们当前的接收到的广播是否为有序广播 ContentProvider&amp; 数据库 ContentProvider 是如何实现数据共享的？ 在 Android 中如果想将自己应用的数据（一般多为数据库中的数据）提供给第三发应用，那么我们只能通过ContentProvider 来实现了。ContentProvider 是应用程序之间共享数据的接口。使用的时候首先自定义一个类继承 ContentProvider，然后覆写 query、insert、update、delete 等方法。因为其是四大组件之一因此必须在 AndroidManifest 文件中进行注册。 为什么要用 ContentProvider？它和 sql 的实现上有什么差别？ ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的 uri 就可以了，ContentProvider 可以实现不同 app 之间共享。Sql 也有增删改查的方法，但是 sql 只能查询本应用下的数据库。而 ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。 ContentProvider、ContentResolver、ContentObserver 之间的关系 ContentProvider 内容提供者，用于对外提供数据ContentResolver.notifyChange(uri)发出消息ContentResolver 内容解析者，用于获取内容提供者提供的数据ContentObserver 内容监听器，可以监听数据的改变状态ContentResolver.registerContentObserver()监听消息。","categories":[{"name":"android","slug":"android","permalink":"http://lingkeyu.com/categories/android/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"http://lingkeyu.com/tags/知识管理/"},{"name":"Android","slug":"Android","permalink":"http://lingkeyu.com/tags/Android/"}]}]}